<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#000000">
  
  <!-- DNS Prefetch for external resources -->
  <link rel="dns-prefetch" href="//fonts.googleapis.com">
  <link rel="dns-prefetch" href="//fonts.gstatic.com">
  <link rel="dns-prefetch" href="//kit.fontawesome.com">
  <link rel="dns-prefetch" href="//audioplayerbackend.onrender.com">
  
  <!-- Preconnect to critical domains -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://audioplayerbackend.onrender.com" crossorigin>
  
  <!-- Critical CSS loaded synchronously to prevent FOUC -->
  <link rel="stylesheet" href="AudioPlayer.css">
  <link rel="stylesheet" href="AudioLogin.css">
  
  <!-- Non-critical CSS can still be preloaded -->
  <link rel="preload" href="https://fonts.googleapis.com/icon?family=Material+Icons" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"></noscript>
  
  <!-- FontAwesome - defer loading -->
  <link rel="preload" href="Assets/css/all.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="Assets/css/all.css"></noscript>
  
  <title>BLACKWHITE</title>
  
  <!-- Favicon resources -->
  <link rel="apple-touch-icon" sizes="180x180" href="SystemImages/favicon_io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="SystemImages/favicon_io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="SystemImages/favicon_io/favicon-16x16.png">
  <link rel="manifest" href="SystemImages/favicon_io/site.webmanifest">
  
  <!-- Prefetch critical images that will be used -->
  <script>
    // Dynamic prefetching based on user role/common assets
    window.prefetchAssets = function() {
      // Common system images
      const criticalImages = [
        'SystemImages/favicon_io/apple-touch-icon.png',
        'SystemImages/favicon_io/favicon-32x32.png',
        'SystemImages/favicon_io/favicon-16x16.png'
      ];
      
      // Prefetch critical images
      criticalImages.forEach(src => {
        const link = document.createElement('link');
        link.rel = 'prefetch';
        link.href = src;
        link.as = 'image';
        document.head.appendChild(link);
      });
    };
    
    // Prefetch assets after page loads
    window.addEventListener('load', () => {
      requestIdleCallback(() => {
        window.prefetchAssets();
      });
    });
  </script>

  <!-- Prevent login page flicker by checking auth immediately -->
  <script>
    // Quick auth check to prevent flicker
    (function() {
      const hasTokens = sessionStorage.getItem('accessToken') && sessionStorage.getItem('refreshToken');
      const timestamp = sessionStorage.getItem('tokenTimestamp');
      const expiration = sessionStorage.getItem('tokenExpiration');
      
      // Check if tokens exist and aren't expired
      const isTokenValid = hasTokens && expiration && (Date.now() < parseInt(expiration));
      
      if (isTokenValid) {
        // Hide login page immediately if we have valid tokens
        document.documentElement.style.setProperty('--initial-login-display', 'none');
        document.documentElement.style.setProperty('--initial-home-display', 'block');
        document.documentElement.style.setProperty('--initial-disguise-display', 'none');
      } else {
        // Show login page if no valid tokens - ensure white background
        document.documentElement.style.setProperty('--initial-login-display', 'block');
        document.documentElement.style.setProperty('--initial-home-display', 'none');
        document.documentElement.style.setProperty('--initial-disguise-display', 'none');
        document.body.style.backgroundColor = "white";
        document.body.classList.add("login-active");
      }
    })();
  </script>

  <style>
    /* Critical styles inlined to prevent FOUC (Flash of Unstyled Content) */
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: white;
    }
    
    /* Hide all content initially to prevent unstyled flash */
    .login-box, .home-box {
      opacity: 0;
    }
    
    /* Show content when styles are loaded */
    .styles-loaded .login-box,
    .styles-loaded .home-box {
      opacity: 1;
    }
    
    /* Use CSS variables to prevent flicker */
    :root {
      --initial-login-display: block;
      --initial-home-display: none;
      --initial-disguise-display: none;
    }
    
    /* Default to white background for login page */
    body {
      background-color: white;
    }
    
    /* Login page should always have white background */
    body:has(#LoginPage[style*="display: block"]) {
      background-color: white !important;
    }
    
    /* When login page is visible via CSS variables, ensure white background */
    body:has(#LoginPage[style*="--initial-login-display: block"]),
    body:has(#LoginPage) {
      background-color: white;
    }
    
    /* Fallback for browsers that don't support :has() */
    .login-active {
      background-color: white !important;
    }
    
    #LoginPage {
      display: var(--initial-login-display) !important;
    }
    
    #HomePage {
      display: var(--initial-home-display) !important;
    }
    
    #DisguisePage {
      display: var(--initial-disguise-display) !important;
    }
    
    /* Force white background when login page is showing */
    #LoginPage:not([style*="display: none"]) ~ * {
      /* This targets elements after login page when it's visible */
    }
    
    /* Ensure login page visibility forces white background */
    body:has(#LoginPage:not([style*="display: none"])) {
      background-color: white !important;
    }

    /* Override when JavaScript updates display */
    #LoginPage[style*="display: block"] {
      display: block !important;
    }
    
    #HomePage[style*="display: block"] {
      display: block !important;
    }
    
    #DisguisePage[style*="display: block"] {
      display: block !important;
    }
    
    #LoginPage[style*="display: none"] {
      display: none !important;
    }
    
    #HomePage[style*="display: none"] {
      display: none !important;
    }
    
    #DisguisePage[style*="display: none"] {
      display: none !important;
    }
  </style>
</head>
<body>

  <div id="LoginPage" class="login-box">
    <div class="login-header">
        <header>SIGN-IN</header>
    </div>
    <div class="input-box">
        <input id="username" type="text" class="input-field" placeholder="ENTER YOUR USERNAME" autocomplete="off">
    </div>
    <div class="input-box">
        <input id="password" type="password" class="input-field" placeholder="ENTER YOUR PASSWORD" autocomplete="off">
    </div>
    <div class="login-message">
        <p id="MessageBox"></p>
    </div>
    <!-- Loading indicator -->
    <div id="loadingIndicator" class="loading-indicator" style="display: none;">
        <p>AUTHENTICATING...</p>
    </div>
    <div class="input-submit">
        <button class="submit-btn" id="signinBtn">SIGN IN</button>
    </div>
  </div>

  <div id="HomePage" class="home-box">
    <div class="wrapper" id="wrapper">
      <div class="top-bar">
        <button id="modeToggle" class="DarkMode">
          <i id="fontawesome-icons" class="fa-solid fa-moon fa-3x"></i>
        </button>
        <span id="title" class="title">BLACKWHITE</span>
        <i id="muteButton" class="material-icons seeVideo">star</i>
      </div>
      <div id="moreOptionsPage" class="more-options" style="display: none;">
        <p id="moreOptionsTitle" class="more-options-title">MORE OPTIONS</p>
        <button id="Add" class="more-options-button">ADD</button>
        <button class="more-options-button">EDIT</button>
        <button class="more-options-button">DELETE</button>
        <button class="more-options-button">CLOSE</button>
      </div>
      <div class="Major-Container">
        <div class="img-area" id="media-container">
          <!-- This area will dynamically include either an img or video elements -->
        </div>
        <div id="video-border-box" class="video-border-box"></div>
        <video id="video" class="overlay-video" src="" playsinline muted loop preload="metadata"></video>
      </div>
      <div class="song-details">
        <p class="name"></p>
        <p class="artist"></p>
      </div>
      <div class="control-box">
        <div class="progress-area">
          <div class="progress-bar">
            <audio id="main-audio" src="" preload="metadata"></audio>
          </div>
          <div class="song-timer">
            <span class="current-time">0:00</span>
            <span class="max-duration">0:00</span>
          </div>
        </div>
        <div class="controls">
          <i id="repeat-plist" class="material-icons" title="Playlist looped">repeat</i>
          <i id="prev" class="material-icons">skip_previous</i>
          <div class="play-pause">
            <i class="material-icons play">play_arrow</i>
          </div>
          <i id="next" class="material-icons">skip_next</i>
          <i id="more-music" class="material-icons">queue_music</i>
        </div>
      </div>
      <div class="music-list">
        <div class="header">
          <div class="row">
            <i class="list material-icons">queue_music</i>
            <span>Music list</span>
          </div>
          <i id="close" class="material-icons">close</i>
        </div>
        <ul>
          <!-- here li list are coming from js -->
        </ul>
      </div>
    </div>
  </div>

  <div id="DisguisePage" class="home-box">
    <div class="wrapper" id="wrapper2">
      <div class="top-bar">
        <button id="modeToggle2" class="DarkMode">
          <i id="fontawesome-icons2" class="fa-solid fa-moon fa-3x"></i>
        </button>
        <span id="title2" class="title">BLACKWHITE</span>
        <i id="muteButton2" class="material-icons seeAllMusic" style="pointer-events: none;">star</i>
      </div>
      <div class="Major-Container">
        <div class="img-area" id="media-container2">
          <!-- This area will dynamically include either an img or video elements -->
        </div>
        <div id="video-border-box2" class="video-border-box" style="display: none;"></div>
        <video id="video2" class="overlay-video" style="border: none; display: none;" src="" autoplay playsinline muted loop preload="metadata"></video>
      </div>
      <div class="song-details">
        <p class="name"></p>
        <p class="artist"></p>
      </div>
      <div class="control-box">
        <div class="progress-area">
          <div class="progress-bar">
            <audio id="main-audio2" src="" preload="metadata"></audio>
          </div>
          <div class="song-timer">
            <span class="current-time">0:00</span>
            <span class="max-duration">0:00</span>
          </div>
        </div>
        <div class="controls">
          <i id="repeat-plist2" class="material-icons" title="Playlist looped">repeat</i>
          <i id="prev2" class="material-icons">skip_previous</i>
          <div class="play-pause">
            <i class="material-icons play">play_arrow</i>
          </div>
          <i id="next2" class="material-icons">skip_next</i>
          <i id="more-music2" class="material-icons">queue_music</i>
        </div>
      </div>
      <div class="music-list">
        <div class="header">
          <div class="row">
            <i class="list material-icons">queue_music</i>
            <span>Music list</span>
          </div>
          <i id="close2" class="material-icons" style="color: black;">close</i>
        </div>
        <ul>
          <!-- here li list are coming from js -->
        </ul>
      </div>
    </div>
  </div>

  <!-- Enhanced Secure Authentication System with Fixed Session Management -->
  <script>
    // API Configuration
    const API_BASE_URL = 'https://audioplayerbackend.onrender.com';
    
    // Enhanced prefetching and caching
    class AssetManager {
        constructor() {
            this.prefetchedAssets = new Set();
            this.imageCache = new Map();
        }

        async prefetchImage(src) {
            if (this.prefetchedAssets.has(src)) return;
            
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    this.imageCache.set(src, img);
                    this.prefetchedAssets.add(src);
                    resolve(img);
                };
                img.onerror = reject;
                img.src = src;
            });
        }

        async prefetchAudio(src) {
            if (this.prefetchedAssets.has(src)) return;
            
            return new Promise((resolve, reject) => {
                const audio = new Audio();
                audio.preload = 'metadata';
                audio.oncanplaythrough = () => {
                    this.prefetchedAssets.add(src);
                    resolve(audio);
                };
                audio.onerror = reject;
                audio.src = src;
            });
        }

        async prefetchVideo(src) {
            if (this.prefetchedAssets.has(src)) return;
            
            const video = document.createElement('video');
            video.preload = 'metadata';
            video.src = src;
            this.prefetchedAssets.add(src);
            return video;
        }

        // Prefetch based on playlist data
        async prefetchPlaylistAssets(playlist) {
            const prefetchPromises = [];
            
            playlist.forEach((track, index) => {
                // Prefetch next 3 tracks
                if (index < 3) {
                    if (track.image) {
                        prefetchPromises.push(this.prefetchImage(track.image));
                    }
                    if (track.video) {
                        prefetchPromises.push(this.prefetchVideo(track.video));
                    }
                    if (track.audio) {
                        prefetchPromises.push(this.prefetchAudio(track.audio));
                    }
                }
            });

            try {
                await Promise.allSettled(prefetchPromises);
                console.log('Prefetched', prefetchPromises.length, 'assets');
            } catch (error) {
                console.warn('Some assets failed to prefetch:', error);
            }
        }
    }

    // Initialize asset manager
    const assetManager = new AssetManager();
    
    // State management
    let currentUser = null;
    let accessToken = null;
    let refreshToken = null;
    let loginAttempts = 0;
    const maxAttempts = 3;
    let sessionCheckInterval = null;
    let serverConnectionEstablished = false;

    // Enhanced API Helper functions
    const SecureAPI = {
        async request(endpoint, options = {}) {
            const url = `${API_BASE_URL}${endpoint}`;
            const config = {
                headers: {
                    'Content-Type': 'application/json',
                    ...(accessToken && { 'Authorization': `Bearer ${accessToken}` })
                },
                timeout: 10000,
                ...options
            };

            if (config.body && typeof config.body === 'object') {
                config.body = JSON.stringify(config.body);
            }

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), config.timeout);
                
                const response = await fetch(url, {
                    ...config,
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'REQUEST FAILED');
                }

                return data;
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw new Error('REQUEST TIMED OUT. PLEASE CHECK YOUR CONNECTION.');
                }
                if (error.name === 'TypeError' && error.message === 'Failed to fetch') {
                    throw new Error('CANNOT CONNECT TO SERVER. PLEASE CHECK YOUR INTERNET CONNECTION.');
                }
                throw error;
            }
        },

        async login(username, password) {
            return this.request('/api/auth/login', {
                method: 'POST',
                body: { username, password }
            });
        },

        async logout() {
            return this.request('/api/auth/logout', {
                method: 'POST'
            });
        },

        async getUserProfile() {
            return this.request('/api/user/profile');
        },

        async refreshAccessToken() {
            return this.request('/api/auth/refresh', {
                method: 'POST',
                body: { refreshToken }
            });
        },

        // Test backend connection with retry
        async testConnection(retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(`${API_BASE_URL}/health`, { timeout: 5000 });
                    if (response.ok) {
                        const data = await response.json();
                        console.log('Backend connection successful:', data);
                        return true;
                    }
                } catch (error) {
                    console.warn(`Backend connection attempt ${i + 1} failed:`, error);
                    if (i < retries - 1) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
            }
            return false;
        }
    };

    // UI Helper functions
    function showMessage(text, isSuccess = false) {
        const messageBox = document.getElementById("MessageBox");
        if (messageBox) {
            messageBox.textContent = text.toUpperCase();
            messageBox.style.color = "#000000";
            messageBox.style.display = "block";
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (messageBox.textContent === text.toUpperCase()) {
                    messageBox.style.display = "none";
                }
            }, 5000);
        }
    }

    function showLoading(show = true) {
        const loadingEl = document.getElementById("loadingIndicator");
        const signInBtn = document.getElementById("signinBtn");
        const messageBox = document.getElementById("MessageBox");
        
        if (show) {
            if (loadingEl) loadingEl.style.display = "none";
            
            if (messageBox) {
                messageBox.textContent = "AUTHENTICATING CREDENTIALS...";
                messageBox.style.color = "#000000";
                messageBox.style.display = "block";
            }
            
            if (signInBtn) {
                signInBtn.disabled = true;
                signInBtn.textContent = "SIGNING IN...";
                signInBtn.style.opacity = "0.7";
            }
        } else {
            if (loadingEl) loadingEl.style.display = "none";
            
            if (signInBtn) {
                signInBtn.disabled = false;
                signInBtn.textContent = "SIGN IN";
                signInBtn.style.opacity = "1";
            }
        }
    }

    function clearInputFields() {
        const username = document.getElementById("username");
        const password = document.getElementById("password");
        const messageBox = document.getElementById("MessageBox");
        
        if (username) username.value = "";
        if (password) password.value = "";
        if (messageBox) {
            messageBox.textContent = "";
            messageBox.style.display = "none";
        }
    }

    // Enhanced token management with proper expiration
    function saveTokens(tokens) {
        accessToken = tokens.accessToken;
        refreshToken = tokens.refreshToken;
        const expirationTime = Date.now() + (23 * 60 * 60 * 1000); // 23 hours from now
        
        sessionStorage.setItem('accessToken', accessToken);
        sessionStorage.setItem('refreshToken', refreshToken);
        sessionStorage.setItem('tokenTimestamp', Date.now().toString());
        sessionStorage.setItem('tokenExpiration', expirationTime.toString());
    }

    function loadTokens() {
        accessToken = sessionStorage.getItem('accessToken');
        refreshToken = sessionStorage.getItem('refreshToken');
        const timestamp = sessionStorage.getItem('tokenTimestamp');
        const expiration = sessionStorage.getItem('tokenExpiration');
        
        // Check if tokens are expired
        if (expiration && Date.now() > parseInt(expiration)) {
            console.log('Tokens expired, clearing session');
            clearTokens();
            return false;
        }
        
        // Check if tokens are too old (fallback check)
        if (timestamp && Date.now() - parseInt(timestamp) > 24 * 60 * 60 * 1000) {
            console.log('Tokens too old, clearing session');
            clearTokens();
            return false;
        }
        
        return !!(accessToken && refreshToken);
    }

    // Stop all media when session ends
    function stopAllMedia() {
        // Stop all audio elements
        const audioElements = document.querySelectorAll('audio');
        audioElements.forEach(audio => {
            audio.pause();
            audio.currentTime = 0;
            audio.src = '';
        });
        
        // Stop all video elements
        const videoElements = document.querySelectorAll('video');
        videoElements.forEach(video => {
            video.pause();
            video.currentTime = 0;
            video.src = '';
        });
    }

    function clearTokens() {
        accessToken = null;
        refreshToken = null;
        currentUser = null;
        
        // Clear all session data
        sessionStorage.removeItem('accessToken');
        sessionStorage.removeItem('refreshToken');
        sessionStorage.removeItem('tokenTimestamp');
        sessionStorage.removeItem('tokenExpiration');
        sessionStorage.removeItem('HomeLoginTime');
        sessionStorage.removeItem('DisguiseLoginTime');
        
        // Stop any ongoing audio/video
        stopAllMedia();
    }

    // Session monitoring functions
    function startSessionMonitoring() {
        // Clear any existing interval
        if (sessionCheckInterval) {
            clearInterval(sessionCheckInterval);
        }
        
        sessionCheckInterval = setInterval(() => {
            if (accessToken) {
                const expiration = sessionStorage.getItem('tokenExpiration');
                const timeUntilExpiry = expiration ? parseInt(expiration) - Date.now() : 0;
                
                // If less than 1 hour remaining, try to refresh
                if (timeUntilExpiry < (60 * 60 * 1000) && timeUntilExpiry > 0) {
                    console.log('Token expiring soon, refreshing...');
                    refreshTokenIfNeeded();
                }
                // If expired, end session
                else if (timeUntilExpiry <= 0) {
                    console.log('Session expired during monitoring');
                    handleLogout(true);
                }
            }
        }, 5 * 60 * 1000); // Check every 5 minutes
    }

    function stopSessionMonitoring() {
        if (sessionCheckInterval) {
            clearInterval(sessionCheckInterval);
            sessionCheckInterval = null;
        }
    }

    // Authentication functions
    async function handleSecureLogin() {
      const username = document.getElementById("username").value.trim();
      const password = document.getElementById("password").value;

      if (!username || !password) {
          showMessage("PLEASE ENTER BOTH USERNAME AND PASSWORD");
          return;
      }

      if (loginAttempts >= maxAttempts) {
          showMessage("MAXIMUM LOGIN ATTEMPTS REACHED. PLEASE WAIT BEFORE TRYING AGAIN.");
          return;
      }

      // NEW: Check if server connection is established
      if (!serverConnectionEstablished) {
          showMessage("ESTABLISHING CONNECTION... PLEASE WAIT A MOMENT");
          
          // Try to establish connection
          const isConnected = await SecureAPI.testConnection();
          if (!isConnected) {
              showMessage("UNABLE TO CONNECT TO SERVER. PLEASE CHECK YOUR INTERNET CONNECTION.");
              return;
          }
          serverConnectionEstablished = true;
      }

      showLoading(true);

      try {
          const response = await SecureAPI.login(username, password);
          
          if (response.success) {
              currentUser = response.data.user;
              saveTokens({
                  accessToken: response.data.accessToken,
                  refreshToken: response.data.refreshToken
              });

              clearInputFields();
              loginAttempts = 0;
              
              // Always go to homepage after successful login
              showHomePage();
              
              // Prefetch assets based on user role
              requestIdleCallback(() => {
                  if (currentUser.role === 'home' && window.allMusic) {
                      assetManager.prefetchPlaylistAssets(window.allMusic);
                  } else if (currentUser.role === 'disguise' && window.allMusicDisguise) {
                      assetManager.prefetchPlaylistAssets(window.allMusicDisguise);
                  }
              });
              
              showMessage("LOGIN SUCCESSFUL", true);
          }
      } catch (error) {
          console.error('Login error:', error);
          
          let errorMessage = (error.message || 'LOGIN FAILED. PLEASE TRY AGAIN.').toUpperCase();
          
          if (error.message && error.message.includes('TOO MANY LOGIN ATTEMPTS')) {
              showMessage(errorMessage);
              loginAttempts = maxAttempts;
          } else {
              loginAttempts++;
              
              if (loginAttempts < maxAttempts) {
                  const remaining = maxAttempts - loginAttempts;
                  errorMessage += ` [${remaining}] ATTEMPTS REMAINING`;
              } else {
                  errorMessage = "MAXIMUM LOGIN ATTEMPTS REACHED. PLEASE WAIT BEFORE TRYING AGAIN.";
                  setTimeout(() => {
                      loginAttempts = 0;
                      showMessage("YOU CAN TRY LOGGING IN AGAIN NOW.", true);
                  }, 15 * 60 * 1000);
              }
              
              showMessage(errorMessage);
          }
      } finally {
          showLoading(false);
      }
  }

    // Page navigation functions with session monitoring
    function showLoginPage() {
        document.getElementById("LoginPage").style.display = "block";
        document.getElementById("HomePage").style.display = "none";
        document.getElementById("DisguisePage").style.display = "none";
        
        // Ensure white background for login page
        document.body.style.backgroundColor = "white";
        document.body.classList.add("login-active");
        
        // Update CSS variables to reflect current state
        document.documentElement.style.setProperty('--initial-login-display', 'block');
        document.documentElement.style.setProperty('--initial-home-display', 'none');
        document.documentElement.style.setProperty('--initial-disguise-display', 'none');
        
        // Stop monitoring when showing login page
        stopSessionMonitoring();
    }

    function showHomePage() {
        document.getElementById("LoginPage").style.display = "none";
        document.getElementById("HomePage").style.display = "block";
        document.getElementById("DisguisePage").style.display = "none";
        
        // Remove login background override and set background to black
        document.body.classList.remove("login-active");
        document.body.style.backgroundColor = "black";
        
        // Update CSS variables to reflect current state
        document.documentElement.style.setProperty('--initial-login-display', 'none');
        document.documentElement.style.setProperty('--initial-home-display', 'block');
        document.documentElement.style.setProperty('--initial-disguise-display', 'none');
        
        sessionStorage.setItem("HomeLoginTime", new Date().getTime());
        sessionStorage.removeItem("DisguiseLoginTime");
        
        // Start monitoring when logged in
        startSessionMonitoring();
    }

    function showDisguisePage() {
        document.getElementById("LoginPage").style.display = "none";
        document.getElementById("HomePage").style.display = "none";
        document.getElementById("DisguisePage").style.display = "block";
        
        // Remove login background override and set background to black
        document.body.classList.remove("login-active");
        document.body.style.backgroundColor = "black";
        
        // Update CSS variables to reflect current state
        document.documentElement.style.setProperty('--initial-login-display', 'none');
        document.documentElement.style.setProperty('--initial-home-display', 'none');
        document.documentElement.style.setProperty('--initial-disguise-display', 'block');
        
        sessionStorage.setItem("DisguiseLoginTime", new Date().getTime());
        sessionStorage.removeItem("HomeLoginTime");
        
        // Start monitoring when logged in
        startSessionMonitoring();
    }

    // Enhanced auth status check with better session validation
    async function checkAuthStatus() {
        if (!loadTokens()) {
            console.log('No valid tokens found, showing login');
            showLoginPage();
            return;
        }

        try {
            const userResponse = await SecureAPI.getUserProfile();
            if (userResponse.success) {
                currentUser = userResponse.data;
                
                // Update token expiration on successful API call
                const newExpiration = Date.now() + (23 * 60 * 60 * 1000);
                sessionStorage.setItem('tokenExpiration', newExpiration.toString());
                
                if (currentUser.role === 'home') {
                    showHomePage();
                } else if (currentUser.role === 'disguise') {
                    showDisguisePage();
                }
            }
        } catch (error) {
            console.error('Auth check failed:', error);
            
            // Try to refresh token once
            const refreshed = await refreshTokenIfNeeded();
            if (!refreshed) {
                console.log('Token refresh failed, ending session');
                handleLogout(true);
            }
        }
    }

    // Enhanced token refresh with proper error handling
    async function refreshTokenIfNeeded() {
        if (!refreshToken) {
            console.log('No refresh token available');
            return false;
        }

        try {
            console.log('Attempting to refresh access token...');
            const response = await SecureAPI.refreshAccessToken();
            
            if (response.success) {
                accessToken = response.data.accessToken;
                const newExpiration = Date.now() + (23 * 60 * 60 * 1000);
                
                sessionStorage.setItem('accessToken', accessToken);
                sessionStorage.setItem('tokenTimestamp', Date.now().toString());
                sessionStorage.setItem('tokenExpiration', newExpiration.toString());
                
                console.log('Token refreshed successfully');
                return true;
            }
        } catch (error) {
            console.error('Token refresh failed:', error);
            handleLogout(false);
        }
        return false;
    }

    // Enhanced logout function with better cleanup
    async function handleLogout(showMessageFlag = true) {
        console.log('Logging out user...');
        
        try {
            if (accessToken) {
                await SecureAPI.logout();
            }
        } catch (error) {
            console.error('Logout API error:', error);
        } finally {
            clearTokens();
            clearInputFields();
            showLoginPage();
            
            if (showMessageFlag) {
                showMessage("SESSION ENDED - PLEASE LOG IN AGAIN", true);
            }
        }
    }

    // Token refresh scheduler
    function startTokenRefreshScheduler() {
        // Refresh token every 45 minutes if we have valid tokens
        setInterval(async () => {
            if (accessToken && refreshToken) {
                const expiration = sessionStorage.getItem('tokenExpiration');
                const timeUntilExpiry = expiration ? parseInt(expiration) - Date.now() : 0;
                
                // Only refresh if we have more than 30 minutes left
                if (timeUntilExpiry > (30 * 60 * 1000)) {
                    await refreshTokenIfNeeded();
                }
            }
        }, 45 * 60 * 1000);
    }

    // App initialization
    async function initializeApp() {
      console.log('Connecting to backend at:', API_BASE_URL);
      
      // Don't show connection messages if we already have valid tokens
      const hasValidTokens = loadTokens();
      
      if (!hasValidTokens) {
          showMessage('CONNECTING TO SERVER...', true);
      }
      
      const isConnected = await SecureAPI.testConnection();
      if (!isConnected) {
          if (!hasValidTokens) {
              showMessage('WARNING: BACKEND CONNECTION FAILED. PLEASE CHECK SERVER STATUS.');
          }
          serverConnectionEstablished = false; // NEW: Mark as not connected
      } else {
          console.log('Backend connection successful');
          serverConnectionEstablished = true; // NEW: Mark as connected
          if (!hasValidTokens) {
              showMessage('SERVER CONNECTION ESTABLISHED', true);
          }
      }
      
      // Always check auth status regardless of connection
      await checkAuthStatus();
  }

    // Event listeners
    document.addEventListener('DOMContentLoaded', function() {
        // Add styles-loaded class to prevent FOUC
        document.body.classList.add('styles-loaded');
        
        // Initialize immediately
        initializeApp();
        
        // Start session monitoring and token refresh scheduler
        startSessionMonitoring();
        startTokenRefreshScheduler();
        
        // Handle page visibility changes (user switches tabs/apps)
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden && accessToken) {
                // Page became visible, check if session is still valid
                checkAuthStatus();
            }
        });
        
        // Handle page unload - cleanup
        window.addEventListener('beforeunload', function() {
            stopSessionMonitoring();
        });
        
        // Sign in button
        const signinBtn = document.getElementById("signinBtn");
        if (signinBtn) {
            signinBtn.addEventListener("click", function(e) {
                e.preventDefault();
                handleSecureLogin();
            });
        }

        // Title logout functionality
        ["title", "title2"].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener("click", function() {
                    // Add visual feedback
                    this.style.opacity = "0.7";
                    setTimeout(() => {
                        this.style.opacity = "1";
                    }, 150);
                    
                    // Perform logout
                    handleLogout();
                });
                
                // Add hover effect to indicate it's clickable
                element.style.cursor = "pointer";
                element.title = "Click to logout";
            }
        });

        // Keyboard support
        const usernameField = document.getElementById("username");
        const passwordField = document.getElementById("password");
        
        if (usernameField) {
            usernameField.addEventListener("keypress", function(event) {
                if (event.key === "Enter") {
                    passwordField?.focus();
                }
            });
        }
        
        if (passwordField) {
            passwordField.addEventListener("keypress", function(event) {
                if (event.key === "Enter") {
                    handleSecureLogin();
                }
            });
        }

        // Network status monitoring
        let wasOffline = false;
        
        window.addEventListener('online', () => {
            console.log('Connection restored');
            showMessage('CONNECTION RESTORED', true);
            if (wasOffline) {
                checkAuthStatus();
                wasOffline = false;
            }
        });

        window.addEventListener('offline', () => {
            wasOffline = true;
            showMessage('NETWORK CONNECTION LOST. PLEASE CHECK YOUR INTERNET CONNECTION.');
        });
    });

    // Expose functions globally for compatibility
    window.handleSecureLogin = handleSecureLogin;
    window.handleLogout = handleLogout;
    window.assetManager = assetManager;
    
    // Legacy compatibility functions
    window.changeText = function(isSuccessful) {
        showMessage(isSuccessful ? "LOGIN SUCCESSFUL" : "LOGIN UNSUCCESSFUL", isSuccessful);
    };
    
    window.clearInputFields = clearInputFields;
    window.checkLoginStatus = checkAuthStatus;
  </script>

  <!-- Your existing scripts in original order -->
  <script src="AudioList.js"></script>
  <script src="AudioPlayer00.js"></script>
  <script src="ServiceWorker.js"></script>
  <script src="https://kit.fontawesome.com/3c627968c9.js" crossorigin="anonymous"></script>
</body>
</html>