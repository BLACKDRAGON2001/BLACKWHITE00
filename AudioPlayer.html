<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#000000">
  
  <!-- DNS Prefetch for external resources -->
  <link rel="dns-prefetch" href="//fonts.googleapis.com">
  <link rel="dns-prefetch" href="//fonts.gstatic.com">
  <link rel="dns-prefetch" href="//kit.fontawesome.com">
  <link rel="dns-prefetch" href="//audioplayerbackend.onrender.com">
  
  <!-- Preconnect to critical domains -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://audioplayerbackend.onrender.com" crossorigin>
  
  <!-- Critical CSS should be inlined or loaded first -->
  <link rel="preload" href="AudioPlayer.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="AudioPlayer.css"></noscript>
  
  <link rel="preload" href="AudioLogin.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="AudioLogin.css"></noscript>
  
  <!-- Preload critical fonts -->
  <link rel="preload" href="https://fonts.googleapis.com/icon?family=Material+Icons" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"></noscript>
  
  <!-- FontAwesome - defer loading -->
  <link rel="preload" href="Assets/css/all.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="Assets/css/all.css"></noscript>
  
  <title>BLACKWHITE</title>
  
  <!-- Favicon resources -->
  <link rel="apple-touch-icon" sizes="180x180" href="SystemImages/favicon_io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="SystemImages/favicon_io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="SystemImages/favicon_io/favicon-16x16.png">
  <link rel="manifest" href="SystemImages/favicon_io/site.webmanifest">
  
  <!-- Prefetch critical images that will be used -->
  <script>
    // Dynamic prefetching based on user role/common assets
    window.prefetchAssets = function() {
      // Common system images
      const criticalImages = [
        'SystemImages/favicon_io/apple-touch-icon.png',
        'SystemImages/favicon_io/favicon-32x32.png',
        'SystemImages/favicon_io/favicon-16x16.png'
      ];
      
      // Prefetch critical images
      criticalImages.forEach(src => {
        const link = document.createElement('link');
        link.rel = 'prefetch';
        link.href = src;
        link.as = 'image';
        document.head.appendChild(link);
      });
    };
    
    // Prefetch assets after page loads
    window.addEventListener('load', () => {
      requestIdleCallback(() => {
        window.prefetchAssets();
      });
    });
  </script>

  <!-- Prevent login page flicker by checking auth immediately -->
  <script>
    // Quick auth check to prevent flicker
    (function() {
      const hasTokens = sessionStorage.getItem('accessToken') && sessionStorage.getItem('refreshToken');
      const timestamp = sessionStorage.getItem('tokenTimestamp');
      
      // Check if tokens exist and aren't too old (24 hours)
      const isTokenValid = hasTokens && timestamp && (Date.now() - parseInt(timestamp) <= 24 * 60 * 60 * 1000);
      
      if (isTokenValid) {
        // Hide login page immediately if we have valid tokens
        document.documentElement.style.setProperty('--initial-login-display', 'none');
        document.documentElement.style.setProperty('--initial-home-display', 'block');
        document.documentElement.style.setProperty('--initial-disguise-display', 'none');
        document.documentElement.style.setProperty('--initial-bg-color', 'black');
      } else {
        // Show login page if no valid tokens
        document.documentElement.style.setProperty('--initial-login-display', 'block');
        document.documentElement.style.setProperty('--initial-home-display', 'none');
        document.documentElement.style.setProperty('--initial-disguise-display', 'none');
        document.documentElement.style.setProperty('--initial-bg-color', 'white');
      }
    })();
  </script>

  <style>
    /* Use CSS variables to prevent flicker */
    :root {
      --initial-login-display: block;
      --initial-home-display: none;
      --initial-disguise-display: none;
      --initial-bg-color: white;
    }
    
    body {
      background-color: var(--initial-bg-color) !important;
      transition: background-color 0.3s ease;
    }
    
    #LoginPage {
      display: var(--initial-login-display) !important;
    }
    
    #HomePage {
      display: var(--initial-home-display) !important;
    }
    
    #DisguisePage {
      display: var(--initial-disguise-display) !important;
    }

    /* Hidden loading overlay - not used */
    .auth-loading {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Hidden loading overlay - not used -->
  <div id="authLoading" class="auth-loading" style="display: none;"></div>

  <div id="LoginPage" class="login-box">
    <div class="login-header">
        <header>SIGN-IN</header>
    </div>
    <div class="input-box">
        <input id="username" type="text" class="input-field" placeholder="ENTER YOUR USERNAME" autocomplete="off">
    </div>
    <div class="input-box">
        <input id="password" type="password" class="input-field" placeholder="ENTER YOUR PASSWORD" autocomplete="off">
    </div>
    <div class="login-message">
        <p id="MessageBox"></p>
    </div>
    <!-- Loading indicator -->
    <div id="loadingIndicator" class="loading-indicator" style="display: none;">
        <p>AUTHENTICATING...</p>
    </div>
    <div class="input-submit">
        <button class="submit-btn" id="signinBtn">SIGN IN</button>
    </div>
  </div>

  <div id="HomePage" class="home-box">
    <div class="wrapper" id="wrapper">
      <div class="top-bar">
        <button id="modeToggle" class="DarkMode">
          <i id="fontawesome-icons" class="fa-solid fa-moon fa-3x"></i>
        </button>
        <span id="title" class="title">BLACKWHITE</span>
        <i id="muteButton" class="material-icons seeVideo">star</i>
      </div>
      <div id="moreOptionsPage" class="more-options" style="display: none;">
        <p id="moreOptionsTitle" class="more-options-title">MORE OPTIONS</p>
        <button id="Add" class="more-options-button">ADD</button>
        <button class="more-options-button">EDIT</button>
        <button class="more-options-button">DELETE</button>
        <button class="more-options-button">CLOSE</button>
      </div>
      <div class="Major-Container">
        <div class="img-area" id="media-container">
          <!-- This area will dynamically include either an img or video elements -->
        </div>
        <div id="video-border-box" class="video-border-box"></div>
        <video id="video" class="overlay-video" src="" playsinline muted loop preload="metadata"></video>
      </div>
      <div class="song-details">
        <p class="name"></p>
        <p class="artist"></p>
      </div>
      <div class="control-box">
        <div class="progress-area">
          <div class="progress-bar">
            <audio id="main-audio" src="" preload="metadata"></audio>
          </div>
          <div class="song-timer">
            <span class="current-time">0:00</span>
            <span class="max-duration">0:00</span>
          </div>
        </div>
        <div class="controls">
          <i id="repeat-plist" class="material-icons" title="Playlist looped">repeat</i>
          <i id="prev" class="material-icons">skip_previous</i>
          <div class="play-pause">
            <i class="material-icons play">play_arrow</i>
          </div>
          <i id="next" class="material-icons">skip_next</i>
          <i id="more-music" class="material-icons">queue_music</i>
        </div>
      </div>
      <div class="music-list">
        <div class="header">
          <div class="row">
            <i class="list material-icons">queue_music</i>
            <span>Music list</span>
          </div>
          <i id="close" class="material-icons">close</i>
        </div>
        <ul>
          <!-- here li list are coming from js -->
        </ul>
      </div>
    </div>
  </div>

  <div id="DisguisePage" class="home-box">
    <div class="wrapper" id="wrapper2">
      <div class="top-bar">
        <button id="modeToggle2" class="DarkMode">
          <i id="fontawesome-icons2" class="fa-solid fa-moon fa-3x"></i>
        </button>
        <span id="title2" class="title">BLACKWHITE</span>
        <i id="muteButton2" class="material-icons seeAllMusic" style="pointer-events: none;">star</i>
      </div>
      <div class="Major-Container">
        <div class="img-area" id="media-container2">
          <!-- This area will dynamically include either an img or video elements -->
        </div>
        <div id="video-border-box2" class="video-border-box" style="display: none;"></div>
        <video id="video2" class="overlay-video" style="border: none; display: none;" src="" autoplay playsinline muted loop preload="metadata"></video>
      </div>
      <div class="song-details">
        <p class="name"></p>
        <p class="artist"></p>
      </div>
      <div class="control-box">
        <div class="progress-area">
          <div class="progress-bar">
            <audio id="main-audio2" src="" preload="metadata"></audio>
          </div>
          <div class="song-timer">
            <span class="current-time">0:00</span>
            <span class="max-duration">0:00</span>
          </div>
        </div>
        <div class="controls">
          <i id="repeat-plist2" class="material-icons" title="Playlist looped">repeat</i>
          <i id="prev2" class="material-icons">skip_previous</i>
          <div class="play-pause">
            <i class="material-icons play">play_arrow</i>
          </div>
          <i id="next2" class="material-icons">skip_next</i>
          <i id="more-music2" class="material-icons">queue_music</i>
        </div>
      </div>
      <div class="music-list">
        <div class="header">
          <div class="row">
            <i class="list material-icons">queue_music</i>
            <span>Music list</span>
          </div>
          <i id="close2" class="material-icons" style="color: black;">close</i>
        </div>
        <ul>
          <!-- here li list are coming from js -->
        </ul>
      </div>
    </div>
  </div>

  <!-- Enhanced Secure Authentication System -->
  <script>
    // API Configuration - Updated for Render deployment
    const API_BASE_URL = 'https://audioplayerbackend.onrender.com';
    
    // Enhanced prefetching and caching
    class AssetManager {
        constructor() {
            this.prefetchedAssets = new Set();
            this.imageCache = new Map();
        }

        async prefetchImage(src) {
            if (this.prefetchedAssets.has(src)) return;
            
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    this.imageCache.set(src, img);
                    this.prefetchedAssets.add(src);
                    resolve(img);
                };
                img.onerror = reject;
                img.src = src;
            });
        }

        async prefetchAudio(src) {
            if (this.prefetchedAssets.has(src)) return;
            
            return new Promise((resolve, reject) => {
                const audio = new Audio();
                audio.preload = 'metadata';
                audio.oncanplaythrough = () => {
                    this.prefetchedAssets.add(src);
                    resolve(audio);
                };
                audio.onerror = reject;
                audio.src = src;
            });
        }

        async prefetchVideo(src) {
            if (this.prefetchedAssets.has(src)) return;
            
            const video = document.createElement('video');
            video.preload = 'metadata';
            video.src = src;
            this.prefetchedAssets.add(src);
            return video;
        }

        // Prefetch based on playlist data
        async prefetchPlaylistAssets(playlist) {
            const prefetchPromises = [];
            
            playlist.forEach((track, index) => {
                // Prefetch next 3 tracks
                if (index < 3) {
                    if (track.image) {
                        prefetchPromises.push(this.prefetchImage(track.image));
                    }
                    if (track.video) {
                        prefetchPromises.push(this.prefetchVideo(track.video));
                    }
                    if (track.audio) {
                        prefetchPromises.push(this.prefetchAudio(track.audio));
                    }
                }
            });

            try {
                await Promise.allSettled(prefetchPromises);
                console.log('Prefetched', prefetchPromises.length, 'assets');
            } catch (error) {
                console.warn('Some assets failed to prefetch:', error);
            }
        }
    }

    // Initialize asset manager
    const assetManager = new AssetManager();
    
    // State management
    let currentUser = null;
    let accessToken = null;
    let refreshToken = null;
    let loginAttempts = 0;
    const maxAttempts = 3;

    // Enhanced API Helper functions with better error handling
    const SecureAPI = {
        async request(endpoint, options = {}) {
            const url = `${API_BASE_URL}${endpoint}`;
            const config = {
                headers: {
                    'Content-Type': 'application/json',
                    ...(accessToken && { 'Authorization': `Bearer ${accessToken}` })
                },
                timeout: 10000, // 10 second timeout
                ...options
            };

            if (config.body && typeof config.body === 'object') {
                config.body = JSON.stringify(config.body);
            }

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), config.timeout);
                
                const response = await fetch(url, {
                    ...config,
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'REQUEST FAILED');
                }

                return data;
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw new Error('REQUEST TIMED OUT. PLEASE CHECK YOUR CONNECTION.');
                }
                if (error.name === 'TypeError' && error.message === 'Failed to fetch') {
                    throw new Error('CANNOT CONNECT TO SERVER. PLEASE CHECK YOUR INTERNET CONNECTION.');
                }
                throw error;
            }
        },

        async login(username, password) {
            return this.request('/api/auth/login', {
                method: 'POST',
                body: { username, password }
            });
        },

        async logout() {
            return this.request('/api/auth/logout', {
                method: 'POST'
            });
        },

        async getUserProfile() {
            return this.request('/api/user/profile');
        },

        async refreshAccessToken() {
            return this.request('/api/auth/refresh', {
                method: 'POST',
                body: { refreshToken }
            });
        },

        // Test backend connection with retry
        async testConnection(retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(`${API_BASE_URL}/health`, { timeout: 5000 });
                    if (response.ok) {
                        const data = await response.json();
                        console.log('Backend connection successful:', data);
                        return true;
                    }
                } catch (error) {
                    console.warn(`Backend connection attempt ${i + 1} failed:`, error);
                    if (i < retries - 1) {
                        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s before retry
                    }
                }
            }
            return false;
        }
    };

    // UI Helper functions with better performance
    function showMessage(text, isSuccess = false) {
        const messageBox = document.getElementById("MessageBox");
        if (messageBox) {
            messageBox.textContent = text.toUpperCase();
            messageBox.style.color = "#000000";
            messageBox.style.display = "block";
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (messageBox.textContent === text.toUpperCase()) {
                    messageBox.style.display = "none";
                }
            }, 5000);
        }
    }

    function showLoading(show = true) {
        const loadingEl = document.getElementById("loadingIndicator");
        const signInBtn = document.getElementById("signinBtn");
        const messageBox = document.getElementById("MessageBox");
        
        if (show) {
            if (loadingEl) loadingEl.style.display = "none";
            
            if (messageBox) {
                messageBox.textContent = "AUTHENTICATING CREDENTIALS...";
                messageBox.style.color = "#000000";
                messageBox.style.display = "block";
            }
            
            if (signInBtn) {
                signInBtn.disabled = true;
                signInBtn.textContent = "SIGNING IN...";
                signInBtn.style.opacity = "0.7";
            }
        } else {
            if (loadingEl) loadingEl.style.display = "none";
            
            if (signInBtn) {
                signInBtn.disabled = false;
                signInBtn.textContent = "SIGN IN";
                signInBtn.style.opacity = "1";
            }
        }
    }

    function clearInputFields() {
        const username = document.getElementById("username");
        const password = document.getElementById("password");
        const messageBox = document.getElementById("MessageBox");
        
        if (username) username.value = "";
        if (password) password.value = "";
        if (messageBox) {
            messageBox.textContent = "";
            messageBox.style.display = "none";
        }
    }

    // Token management with better security
    function saveTokens(tokens) {
        accessToken = tokens.accessToken;
        refreshToken = tokens.refreshToken;
        // Use sessionStorage for better security (clears on tab close)
        sessionStorage.setItem('accessToken', accessToken);
        sessionStorage.setItem('refreshToken', refreshToken);
        sessionStorage.setItem('tokenTimestamp', Date.now().toString());
    }

    function loadTokens() {
        accessToken = sessionStorage.getItem('accessToken');
        refreshToken = sessionStorage.getItem('refreshToken');
        const timestamp = sessionStorage.getItem('tokenTimestamp');
        
        // Check if tokens are too old (24 hours)
        if (timestamp && Date.now() - parseInt(timestamp) > 24 * 60 * 60 * 1000) {
            clearTokens();
            return false;
        }
        
        return !!(accessToken && refreshToken);
    }

    function clearTokens() {
        accessToken = null;
        refreshToken = null;
        currentUser = null;
        sessionStorage.removeItem('accessToken');
        sessionStorage.removeItem('refreshToken');
        sessionStorage.removeItem('tokenTimestamp');
    }

    // Show loading overlay during auth checks - disabled
    function showAuthLoading(show = true) {
        // Disabled - no overlay shown
        return;
    }

    // Enhanced authentication functions
    async function handleSecureLogin() {
        const username = document.getElementById("username").value.trim();
        const password = document.getElementById("password").value;

        if (!username || !password) {
            showMessage("PLEASE ENTER BOTH USERNAME AND PASSWORD");
            return;
        }

        if (loginAttempts >= maxAttempts) {
            showMessage("MAXIMUM LOGIN ATTEMPTS REACHED. PLEASE WAIT BEFORE TRYING AGAIN.");
            return;
        }

        showLoading(true);

        try {
            const response = await SecureAPI.login(username, password);
            
            if (response.success) {
                currentUser = response.data.user;
                saveTokens({
                    accessToken: response.data.accessToken,
                    refreshToken: response.data.refreshToken
                });

                clearInputFields();
                loginAttempts = 0;
                
                // Navigate and prefetch assets based on user role
                if (currentUser.role === 'home') {
                    showHomePage();
                    // Prefetch home page assets
                    requestIdleCallback(() => {
                        if (window.allMusic) {
                            assetManager.prefetchPlaylistAssets(window.allMusic);
                        }
                    });
                } else if (currentUser.role === 'disguise') {
                    showDisguisePage();
                    // Prefetch disguise page assets
                    requestIdleCallback(() => {
                        if (window.allMusicDisguise) {
                            assetManager.prefetchPlaylistAssets(window.allMusicDisguise);
                        }
                    });
                }
                
                showMessage("LOGIN SUCCESSFUL", true);
            }
        } catch (error) {
            console.error('Login error:', error);
            
            let errorMessage = (error.message || 'LOGIN FAILED. PLEASE TRY AGAIN.').toUpperCase();
            
            if (error.message && error.message.includes('TOO MANY LOGIN ATTEMPTS')) {
                showMessage(errorMessage);
                loginAttempts = maxAttempts;
            } else {
                loginAttempts++;
                
                if (loginAttempts < maxAttempts) {
                    const remaining = maxAttempts - loginAttempts;
                    errorMessage += ` [${remaining}] ATTEMPTS REMAINING`;
                } else {
                    errorMessage = "MAXIMUM LOGIN ATTEMPTS REACHED. PLEASE WAIT BEFORE TRYING AGAIN.";
                    setTimeout(() => {
                        loginAttempts = 0;
                        showMessage("YOU CAN TRY LOGGING IN AGAIN NOW.", true);
                    }, 15 * 60 * 1000);
                }
                
                showMessage(errorMessage);
            }
        } finally {
            showLoading(false);
        }
    }

    // Enhanced page navigation with smooth transitions
    function showLoginPage() {
        document.getElementById("LoginPage").style.display = "block";
        document.getElementById("HomePage").style.display = "none";
        document.getElementById("DisguisePage").style.display = "none";
        document.body.style.backgroundColor = "white";
    }

    function showHomePage() {
        document.getElementById("LoginPage").style.display = "none";
        document.getElementById("HomePage").style.display = "block";
        document.getElementById("DisguisePage").style.display = "none";
        document.body.style.backgroundColor = "black";
        
        sessionStorage.setItem("HomeLoginTime", new Date().getTime());
        sessionStorage.removeItem("DisguiseLoginTime");
    }

    function showDisguisePage() {
        document.getElementById("LoginPage").style.display = "none";
        document.getElementById("HomePage").style.display = "none";
        document.getElementById("DisguisePage").style.display = "block";
        document.body.style.backgroundColor = "black";
        
        sessionStorage.setItem("DisguiseLoginTime", new Date().getTime());
        sessionStorage.removeItem("HomeLoginTime");
    }

    // Enhanced authentication check with immediate feedback
    async function checkAuthStatus() {
        if (!loadTokens()) {
            // Only show login if we weren't already showing it from the initial CSS
            if (document.documentElement.style.getPropertyValue('--initial-login-display') !== 'block') {
                showLoginPage();
            }
            return;
        }

        // If we have tokens, proceed silently
        try {
            const userResponse = await SecureAPI.getUserProfile();
            if (userResponse.success) {
                currentUser = userResponse.data;
                
                if (currentUser.role === 'home') {
                    showHomePage();
                } else if (currentUser.role === 'disguise') {
                    showDisguisePage();
                }
            }
        } catch (error) {
            console.error('Auth check failed:', error);
            
            const refreshed = await refreshTokenIfNeeded();
            if (!refreshed) {
                clearTokens();
                showLoginPage();
                showMessage('SESSION EXPIRED. PLEASE LOG IN AGAIN.');
            }
        }
    }

    async function refreshTokenIfNeeded() {
        if (!refreshToken) return false;

        try {
            const response = await SecureAPI.refreshAccessToken();
            if (response.success) {
                accessToken = response.data.accessToken;
                sessionStorage.setItem('accessToken', accessToken);
                sessionStorage.setItem('tokenTimestamp', Date.now().toString());
                return true;
            }
        } catch (error) {
            console.error('Token refresh failed:', error);
            handleLogout();
        }
        return false;
    }

    async function handleLogout() {
        try {
            if (accessToken) {
                await SecureAPI.logout();
            }
        } catch (error) {
            console.error('Logout error:', error);
        } finally {
            clearTokens();
            clearInputFields();
            showLoginPage();
            showMessage("LOGGED OUT SUCCESSFULLY", true);
        }
    }

    // Enhanced app initialization with immediate UI feedback
    async function initializeApp() {
        console.log('Connecting to backend at:', API_BASE_URL);
        
        // Don't show connection messages if we already have valid tokens
        const hasValidTokens = loadTokens();
        
        if (!hasValidTokens) {
            showMessage('CONNECTING TO SERVER...', true);
        }
        
        const isConnected = await SecureAPI.testConnection();
        if (!isConnected) {
            if (!hasValidTokens) {
                showMessage('WARNING: BACKEND CONNECTION FAILED. PLEASE CHECK SERVER STATUS.');
            }
        } else {
            console.log('Backend connection successful');
            if (!hasValidTokens) {
                showMessage('SERVER CONNECTION ESTABLISHED', true);
            }
        }
        
        // Always check auth status regardless of connection
        await checkAuthStatus();
    }

    // Auto-refresh token every 45 minutes
    setInterval(async () => {
        if (accessToken && refreshToken) {
            await refreshTokenIfNeeded();
        }
    }, 45 * 60 * 1000);

    // Enhanced event listeners
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize immediately
        initializeApp();
        
        // Optimized event listeners
        const signinBtn = document.getElementById("signinBtn");
        if (signinBtn) {
            signinBtn.addEventListener("click", function(e) {
                e.preventDefault();
                handleSecureLogin();
            });
        }

        // Title logout functionality
        ["title", "title2"].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener("click", handleLogout);
            }
        });

        // Enhanced keyboard support
        const usernameField = document.getElementById("username");
        const passwordField = document.getElementById("password");
        
        if (usernameField) {
            usernameField.addEventListener("keypress", function(event) {
                if (event.key === "Enter") {
                    passwordField?.focus();
                }
            });
        }
        
        if (passwordField) {
            passwordField.addEventListener("keypress", function(event) {
                if (event.key === "Enter") {
                    handleSecureLogin();
                }
            });
        }

        // Network status monitoring
        let wasOffline = false;
        
        window.addEventListener('online', () => {
            console.log('Connection restored');
            showMessage('CONNECTION RESTORED', true);
            if (wasOffline) {
                // Re-check auth status when coming back online
                checkAuthStatus();
                wasOffline = false;
            }
        });

        window.addEventListener('offline', () => {
            wasOffline = true;
            showMessage('NETWORK CONNECTION LOST. PLEASE CHECK YOUR INTERNET CONNECTION.');
        });
    });

    // Expose functions globally for compatibility
    window.handleSecureLogin = handleSecureLogin;
    window.handleLogout = handleLogout;
    window.assetManager = assetManager;
    
    // Legacy compatibility functions
    window.changeText = function(isSuccessful) {
        showMessage(isSuccessful ? "LOGIN SUCCESSFUL" : "LOGIN UNSUCCESSFUL", isSuccessful);
    };
    
    window.clearInputFields = clearInputFields;
    window.checkLoginStatus = checkAuthStatus;
  </script>

  <!-- Your existing scripts in original order -->
  <script src="AudioList.js"></script>
  <script src="AudioPlayer00.js"></script>
  <script src="ServiceWorker.js"></script>
  <script src="https://kit.fontawesome.com/3c627968c9.js" crossorigin="anonymous"></script>
</body>
</html>